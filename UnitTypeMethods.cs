/******************************************************************************
**
** <auto-generated>
**     This code was generated by a tool: UaModeler
**     Runtime Version: 1.6.9, using .NET Server 3.3.0 template (version 0)
**
**     This is a template file that was generated for your convenience.
**     This file will not be overwritten when generating code again.
**     ADD YOUR IMPLEMTATION HERE!
** </auto-generated>
**
** Copyright (c) 2006-2023 Unified Automation GmbH All rights reserved.
**
** Software License Agreement ("SLA") Version 2.8
**
** Unless explicitly acquired and licensed from Licensor under another
** license, the contents of this file are subject to the Software License
** Agreement ("SLA") Version 2.8, or subsequent versions
** as allowed by the SLA, and You may not copy or use this file in either
** source code or executable form, except in compliance with the terms and
** conditions of the SLA.
**
** All software distributed under the SLA is provided strictly on an
** "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
** AND LICENSOR HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT
** LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
** PURPOSE, QUIET ENJOYMENT, OR NON-INFRINGEMENT. See the SLA for specific
** language governing rights and limitations under the SLA.
**
** Project: .NET OPC UA SDK information model for namespace http://yourorganisation.org/PackMLModel/
**
** Description: OPC Unified Architecture Software Development Kit.
**
** The complete license agreement can be found here:
** http://unifiedautomation.com/License/SLA/2.8/
**
** Created: 12.07.2023
**
******************************************************************************/

using PackML_v0;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using UnifiedAutomation.UaBase;
using UnifiedAutomation.UaServer;
using static PackML_v0.PackMLStateModel;

namespace FIP.PackMLStateMachine
{
    public partial class UnitModel : PackMLStateModelModel, IUnitMethods
    {
        int SCTime = 3000;
        private readonly DBManager db = new DBManager();

        /// <summary>
        /// Generates the state machine image with the state surrounded with a red marker.
        /// </summary>
        /// <param name="fpath">The path of the blank file</param>
        /// <param name="newfpath">The path of the new file to create</param>
        /// <param name="state">The state to surround</param>
        /// <returns>Returns the byte array of the new image</returns>
        public byte[] GenerateImage(string fpath, string newfpath, int state)
        {
            Image img = Image.FromFile(fpath);
            int x = 0;
            int y = 0;

            // Choose the pixel position depending on the state of the machine.
            switch (state)
            {
                case 1:
                    x = 64;
                    y = 236;
                    break;
                case 2:
                    x = 64;
                    y = 675;
                    break;
                case 3:
                    x = 307;
                    y = 236;
                    break;
                case 4:
                    x = 640;
                    y = 675;
                    break;
                case 5:
                    x = 636;
                    y = 454;
                    break;
                case 6:
                    x = 636;
                    y = 239;
                    break;
                case 7:
                    x = 311;
                    y = 675;
                    break;
                case 8:
                    x = 1208;
                    y = 677;
                    break;
                case 9:
                    x = 975;
                    y = 675;
                    break;
                case 10:
                    x = 964;
                    y = 54;
                    break;
                case 11:
                    x = 620;
                    y = 64;
                    break;
                case 12:
                    x = 307;
                    y = 54;
                    break;
                case 13:
                    x = 964;
                    y = 440;
                    break;
                case 14:
                    x = 307;
                    y = 440;
                    break;
                case 15:
                    x = 64;
                    y = 440;
                    break;
                case 16:
                    x = 964;
                    y = 235;
                    break;
                case 17:
                    x = 1194;
                    y = 235;
                    break;

            }

            Pen pen = new Pen(Color.Red, 8);
            using (Graphics g = Graphics.FromImage(img))
                g.DrawRectangle(pen, x, y, 181, 122);
            img.Save(newfpath);
            return File.ReadAllBytes(newfpath);
        }

        /// <summary>
        /// Update the state of the machine. Also updates the image and will execute the StateComplete command after a certain time.
        /// </summary>
        /// <param name="model"></param>
        /// <param name="state"></param>
        public void UpdateState(UnitModel model, int state)
        {
            model.CurrentState = state;
            model.MachineImage = GenerateImage(@"Data/image.jpg", @"Data/newImage.jpg", state);
            ExecuteSC(model, SCTime);
        }

        /// <summary>
        /// Update the state of the machine. Also updates the image. Will NOT execute the StateComplete command after a certain time.
        /// </summary>
        /// <param name="model"></param>
        /// <param name="state"></param>
        public void UpdateStateNoSC(UnitModel model, int state)
        {
            model.CurrentState = state;
            model.MachineImage = GenerateImage(@"Data/image.jpg", @"Data/newImage.jpg", state);
        }

        /// <summary>
        /// Execute StateCompleted after a certain time
        /// </summary>
        /// <param name="model">The model to apply the command</param>
        /// <param name="scTime">The time to wait before executing the StateCompleted command</param>
        public async void ExecuteSC(UnitModel model, int scTime)
        {
            await Task.Delay(scTime);
            model.SafeMoveNext(null, model, 11);
        }

        /// <summary>
        /// Add an alarm to the machine. If the id of the alarm already exists, replace the existing one.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="alarm">The alarm to add</param>
        /// <returns></returns>
        public StatusCode AddAlarm(
            RequestContext context,
            UnitModel model,
            AlarmType alarm
            )
        {
            if (model.Dictionnaries.Alarms == null)
            {
                model.Dictionnaries.Alarms = new AlarmType[] { };
            }

            bool idExists = false;
            List<AlarmType> alarmsToList = new List<AlarmType>(model.Dictionnaries.Alarms.ToList());

            int key = 0;

            //Check if the alarm exists
            foreach (AlarmType alarmT in alarmsToList)
            {
                if (alarmT.Id == alarm.Id)
                {
                    idExists = true;
                    break;
                }
                key++;
            }

            // If the alarm exists, replace the existing alarm
            if (idExists)
            {
                model.Dictionnaries.Alarms[key] = alarm;
                return StatusCodes.GoodEntryReplaced;
            }
            // Otherwise, add it to the list
            else
            {
                alarmsToList.Add(alarm);
                model.Dictionnaries.Alarms = alarmsToList.ToArray();
            }

            return StatusCodes.GoodEntryInserted;
        }

        /// <summary>
        /// Read a well formated .csv file and add the alarms to the machine. See "_Template_Alarms.csv" in the Data folder to see how to correctly format a .csv file
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="fileName">The name of the .csv file. You need to include the full name, extension included. (for example "alarmfile.csv")</param>
        /// <param name="delimiter">The delimiter of the .csv file. Usually a comma</param>
        /// <returns></returns>
        public StatusCode AddAlarmsFromCSV(
            RequestContext context,
            UnitModel model,
            string fileName,
            string delimiter
            )
        {
            string path = @"Data/" + fileName;
            List<int> alarmsID = new List<int>();
            List<int> commands = new List<int>();
            List<string> messages = new List<string>();
            int lineNumber = 1;
            using (StreamReader reader = new StreamReader(path))
            {
                // Read each line containing the data for the alarms
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    string[] values = line != null ? line.Split(char.Parse(delimiter)) : Array.Empty<string>();
                    if (lineNumber != 1)
                    {
                        alarmsID.Add(int.Parse(values[0]));
                        commands.Add(int.Parse(values[1]));
                        messages.Add(values[2]);
                    }
                    lineNumber++;
                }
            }

            // Add the collected data to the machine
            for (int i = 0; i < alarmsID.Count; i++)
            {
                AlarmType alarm = new AlarmType();
                alarm.Id = alarmsID[i];
                alarm.AlarmTransition = commands[i];
                alarm.AlarmMessage = messages[i];
                AddAlarm(context, model, alarm);
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Add a button to the machine. If the id of the button already exists, replace the existing one.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="button"></param>
        /// <returns></returns>
        public StatusCode AddButtons(
            RequestContext context,
            UnitModel model,
            ButtonType button
            )
        {
            if (model.Dictionnaries.Buttons == null)
            {
                model.Dictionnaries.Buttons = new ButtonType[] { };
            }

            bool idExists = false;
            List<ButtonType> buttonsToList = new List<ButtonType>(model.Dictionnaries.Buttons.ToList());

            int key = 0;

            // Check if the button exists
            foreach (ButtonType buttonT in buttonsToList)
            {
                if (buttonT.Id == button.Id)
                {
                    idExists = true;
                    break;
                }
                key++;
            }

            // If the button exists, replace the existing button
            if (idExists)
            {
                model.Dictionnaries.Buttons[key] = button;
                return StatusCodes.GoodEntryReplaced;
            }
            // Otherwise, add it to the list
            else
            {
                buttonsToList.Add(button);
                model.Dictionnaries.Buttons = buttonsToList.ToArray();
            }

            return StatusCodes.GoodEntryInserted;
        }

        /// <summary>
        /// Read a well formated .csv file and add the buttons to the machine. See "_Template_Commands.csv" in the Data folder to see how to correctly format a .csv file
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="fileName">The name of the .csv file. You need to include the full name, extension included. (for example "buttonfile.csv")</param>
        /// <param name="delimiter">The delimiter of the .csv file. Usually a comma</param>
        /// <returns></returns>
        public StatusCode AddButtonsFromCSV(
            RequestContext context,
            UnitModel model,
            string fileName,
            string delimiter
            )
        {
            string path = @"Data/" + fileName;
            List<int> commandID = new List<int>();
            List<string> commandName = new List<string>();

            List<Command> actionsOfACommand = new List<Command>();
            List<List<Command>> actions = new List<List<Command>>();


            // Read each line containing the data for the stack lights. For "simplicity", the data is read backwards (from bottom to top) 
            using (StreamReader reader = new StreamReader(path))
            {
                Stack<string> lines = new Stack<string>();

                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    lines.Push(line);
                }

                while (lines.Count > 1)
                {
                    string currentLine = lines.Pop();
                    string[] value = currentLine.Split(char.Parse(delimiter));
                    if (value[0] == "")
                    {
                        actionsOfACommand.Add((Command)int.Parse(value[2]));
                    }
                    else
                    {
                        actionsOfACommand.Add((Command)int.Parse(value[2]));
                        actionsOfACommand.Reverse();
                        commandID.Add(int.Parse(value[0]));
                        commandName.Add(value[1]);
                        actions.Add(actionsOfACommand);

                        actionsOfACommand = new List<Command>();
                    }
                }
            }

            List<int[]> actionsArray = new List<int[]>();
            List<int> commandsArrayList = new List<int>();

            foreach (List<Command> commands in actions)
            {
                foreach (int command in commands)
                {
                    commandsArrayList.Add(command);
                }
                actionsArray.Add(commandsArrayList.ToArray());
                commandsArrayList = new List<int>();
            }



            for (int i = commandID.Count - 1; i >= 0; i--)
            {
                ButtonType button = new ButtonType();
                button.Id = commandID[i];
                button.ButtonName = commandName[i];
                button.Commands = actionsArray[i];
                AddButtons(context, model, button);
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Add a stack light to the machine. if the id of the stack light already exists, replace the existing one.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="stacklight"></param>
        /// <returns></returns>
        public StatusCode AddStackLight(
            RequestContext context,
            UnitModel model,
            StackLightType stacklight
            )
        {
            if (model.Dictionnaries.StackLights == null)
            {
                model.Dictionnaries.StackLights = new StackLightType[] { };
            }

            bool idExists = false;
            List<StackLightType> stackLightsToList = new List<StackLightType>(model.Dictionnaries.StackLights.ToList());

            int key = 0;

            // Check if the stack light exists
            foreach (StackLightType alarmT in stackLightsToList)
            {
                if (alarmT.Id == stacklight.Id)
                {
                    idExists = true;
                    break;
                }
                key++;
            }

            // If the stack light exists, replace the existing stack light
            if (idExists)
            {
                model.Dictionnaries.StackLights[key] = stacklight;
                return StatusCodes.GoodEntryReplaced;
            }
            // Otherwise, add it to the list
            else
            {
                stackLightsToList.Add(stacklight);
                model.Dictionnaries.StackLights = stackLightsToList.ToArray();
            }

            return StatusCodes.GoodEntryInserted;
        }

        /// <summary>
        /// Read a well formated .csv file and add the stack lights to the machine. See "_Template_Stacklights.csv" in the Data folder to see how to correctly format a .csv file
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="fileName">The name of the .csv file. You need to include the full name, extension included. (for example "stacklightfile.csv")</param>
        /// <param name="delimiter">The delimiter of the .csv file. Usually a comma</param>
        /// <returns></returns>
        public StatusCode AddStackLightsFromCSV(
            RequestContext context,
            UnitModel model,
            string fileName,
            string delimiter
            )
        {
            string path = @"Data/" + fileName;
            List<int> stacklightID = new List<int>();
            List<string> description = new List<string>();
            int lineNumber = 1;
            using (StreamReader reader = new StreamReader(path))
            {
                // Read each line containing the data for the stack lights
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    string[] values = line != null ? line.Split(char.Parse(delimiter)) : Array.Empty<string>();
                    if (lineNumber != 1)
                    {
                        stacklightID.Add(int.Parse(values[0]));
                        description.Add(values[1]);
                    }
                    lineNumber++;
                }
            }

            // Add the collected data to the machine
            for (int i = 0; i < stacklightID.Count; i++)
            {
                StackLightType stackLightType = new StackLightType();
                stackLightType.Id = stacklightID[i];
                stackLightType.Description = description[i];
                AddStackLight(context, model, stackLightType);
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Helper of the ExecuteProcess function. Made in a separate method to make the function async
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="process"></param>
        /// <returns></returns>
        public async Task<int> ExecuteProcessHelper(RequestContext context,
            UnitModel model,
            ProcessType process
            )
        {
            List<int> ints = new List<int>(process.Commands.ToList());

            Unit unit = new Unit((State)model.CurrentState);

            for (int j = 0; j < process.id; j++)
            {
                int i = 0;
                while (i < process.Commands.Count)
                {
                    // If it's possible to execute StateCompleted, execute it
                    if (unit.IsCommandAvailable(Command.StateCompleted))
                    {
                        await Task.Delay((int)process.SCTime);
                        unit.SafeMoveNext(Command.StateCompleted);
                        UpdateStateNoSC(model, (int)unit.CurrentState);
                    }
                    // Otherwise execute the next command in the process
                    else
                    {
                        await Task.Delay((int)process.CommandTime);
                        unit.SafeMoveNext((Command)process.Commands[i]);
                        UpdateStateNoSC(model, (int)unit.CurrentState);
                        i++;
                    }
                    // If we finished executing the process, try to execute StateCompleted one more time after a certain amount of time
                    if (i == process.Commands.Count)
                    {
                        await Task.Delay((int)process.SCTime);
                        unit.SafeMoveNext(Command.StateCompleted);
                        UpdateStateNoSC(model, (int)unit.CurrentState);

                    }
                }
            }
            return 1;
        }

        /// <summary>
        /// Execute a process to the machine. The machine will execute the commands associated with the process one by one.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="process"></param>
        /// <returns></returns>
        public StatusCode ExecuteProcess(
            RequestContext context,
            UnitModel model,
            ProcessType process
            )
        {
#pragma warning disable CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            ExecuteProcessHelper(context, model, process);
#pragma warning restore CS4014 // Because this call is not awaited, execution of the current method continues before the call is completed
            return StatusCodes.Good;
        }

        /// <summary>
        /// Load the data from a .csv file to the machine. See "__Template_Machine.csv" in the Data folder to see how to format the file correctly.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="csvFileName">The name of the .csv file. You need to include the full name, extension included. (for example "stacklightfile.csv")</param>
        /// <param name="delimiter">The delimiter of the .csv file. Usually a comma</param>
        /// <returns></returns>
        public StatusCode ReadDataFromCSV(
            RequestContext context,
            UnitModel model,
            string csvFileName,
            string delimiter
            )
        {

            string path = @"Data/" + csvFileName;

            List<int> alarmsID = new List<int>();
            List<Command> commands = new List<Command>();
            List<string> messages = new List<string>();

            List<int> stacklightID = new List<int>();
            List<string> description = new List<string>();

            List<int> commandID = new List<int>();
            List<string> commandName = new List<string>();
            List<Command> actionsOfACommand = new List<Command>();
            List<List<Command>> actions = new List<List<Command>>();

            Dictionary<int, bool> alarmsState = new Dictionary<int, bool>();
            Dictionary<int, bool> stackLightsState = new Dictionary<int, bool>();

            State stateMachine = new State();

            int numberOfLine = 0;

            Dictionary<int, int> howManyActionsInThisID = new Dictionary<int, int>();
            int actionsNum = 0;

            using (StreamReader reader = new StreamReader(path))
            {
                // Read data line by line
                while (!reader.EndOfStream)
                {
                    string line = reader.ReadLine();
                    string[] values = line != null ? line.Split(char.Parse(delimiter)) : Array.Empty<string>();
                    numberOfLine++;
                    switch (numberOfLine)
                    {
                        case 1:
                            model.MachineName = values[1];
                            break;
                        case 2:
                            stateMachine = (State)Enum.Parse(typeof(State), values[1]);
                            break;
                        case 4:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    alarmsID.Add(int.Parse(values[i]));
                                }
                            }
                            break;
                        case 5:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    commands.Add((Command)Enum.Parse(typeof(Command), values[i]));
                                }
                            }
                            break;
                        case 6:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    messages.Add(values[i]);
                                }
                            }
                            break;
                        case 7:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    alarmsState[alarmsID[i - 1]] = bool.Parse(values[i]);
                                }
                            }
                            break;
                        case 9:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    stacklightID.Add(int.Parse(values[i]));
                                }
                            }
                            break;
                        case 10:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    description.Add(values[i]);
                                }
                            }
                            break;
                        case 11:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != "")
                                {
                                    stackLightsState[stacklightID[i - 1]] = bool.Parse(values[i]);
                                }
                            }
                            break;

                        case 13:
                            for (int i = 1; i < values.Length; i++)
                            {

                                if (values[i] != values[i - 1])
                                {
                                    actionsNum = 0;
                                    if (values[i] != "")
                                    {
                                        commandID.Add(int.Parse(values[i]));
                                    }
                                }
                                else
                                {
                                    actionsNum++;
                                }
                                if (values[i] != "")
                                {
                                    howManyActionsInThisID[int.Parse(values[i])] = actionsNum + 1;
                                }
                            }
                            break;

                        case 14:
                            for (int i = 1; i < values.Length; i++)
                            {
                                if (values[i] != values[i - 1])
                                {
                                    if (values[i] != "")
                                    {
                                        commandName.Add(values[i]);
                                    }
                                }
                            }
                            break;

                        case 15:
                            int j = 1;
                            foreach (int id in commandID)
                            {
                                for (int i = 1; i <= howManyActionsInThisID[id]; i++)
                                {

                                    if (j < values.Length && values[j] != "")
                                    {
                                        actionsOfACommand.Add((Command)Enum.Parse(typeof(Command), values[j]));
                                    }
                                    j++;
                                }
                                actions.Add(actionsOfACommand);
                                actionsOfACommand = new List<Command>();
                            }
                            break;

                    }
                }
            }

            model.Dictionnaries.Alarms = new AlarmType[] { };
            model.Dictionnaries.StackLights = new StackLightType[] { };
            model.Dictionnaries.Buttons = new ButtonType[] { };


            // Add the data to the machine

            for (int i = 0; i < alarmsID.Count; i++)
            {
                AlarmType alarm = new AlarmType();
                alarm.Id = alarmsID[i];
                alarm.AlarmTransition = (int)commands[i];
                alarm.AlarmMessage = messages[i];
                AddAlarm(context, model, alarm);
            }

            for (int i = 0; i < stacklightID.Count; i++)
            {
                StackLightType stackLightType = new StackLightType();
                stackLightType.Id = stacklightID[i];
                stackLightType.Description = description[i];
                AddStackLight(context, model, stackLightType);
            }

            for (int i = 0; i < commandID.Count; i++)
            {
                ButtonType buttonType = new ButtonType();
                buttonType.Id = commandID[i];
                buttonType.ButtonName = commandName[i];

                List<int> actionsInt = new List<int>();
                foreach (int c in actions[i])
                {
                    actionsInt.Add(c);
                }

                buttonType.Commands = actionsInt.ToArray();

                AddButtons(context, model, buttonType);
            }

            foreach (int id in alarmsState.Keys)
            {
                if (alarmsState[id])
                {
                    _ = TriggerAlarm(context, model, id);
                }
            }

            foreach (int id in stackLightsState.Keys)
            {
                if (stackLightsState[id])
                {
                    _ = TriggerStackLight(context, model, id);
                }
            }

            UpdateState(model, (int)stateMachine);

            return StatusCodes.Good;
        }

        /// <summary>
        /// Load the data from the database file into the machine. (This is broken)
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="DBFileName"></param>
        /// <returns></returns>
        public StatusCode ReadDataFromDB(
            RequestContext context,
            UnitModel model,
            string DBFileName
            )
        {
            model.Dictionnaries.Alarms = new AlarmType[] { };
            model.Dictionnaries.StackLights = new StackLightType[] { };
            model.Dictionnaries.Buttons = new ButtonType[] { };

            Unit unit = new Unit((State)model.CurrentState);
            unit.ReadDataFromDB();
            foreach (int id in unit.GetAllAlarms().Keys)
            {
                AlarmType alarmType = new AlarmType();
                alarmType.Id = id;
                alarmType.AlarmMessage = unit.GetAlarm(id).Message;
                alarmType.AlarmTransition = (int)unit.GetAlarm(id).Command;
                alarmType.On = unit.IsAlarmOn(unit.GetAlarm(id));
                model.AddAlarm(context, model, alarmType);
            }

            foreach (int id in unit.GetAllStackLights().Keys)
            {
                StackLightType stacklightType = new StackLightType();
                stacklightType.Id = id;
                stacklightType.Description = unit.GetStackLight(id).Description;
                stacklightType.On = unit.IsStackLightOn(unit.GetStackLight(id));
                model.AddStackLight(context, model, stacklightType);
            }

            foreach (int id in unit.GetAllCommandsMachine().Keys)
            {
                ButtonType buttonType = new ButtonType();
                buttonType.Id = id;
                buttonType.ButtonName = unit.GetCommandMachine(id).CommandMachineName;

                List<int> commands = new List<int>();

                foreach (int command in unit.GetCommandMachine(id).Commands)
                {
                    commands.Add(command);
                }

                buttonType.Commands = commands.ToArray();
                model.AddButtons(context, model, buttonType);
            }
            model.CurrentState = (int)unit.CurrentState;
            model.MachineName = unit.GetMachineName();

            return StatusCodes.Good;
        }

        /// <summary>
        /// Remove an alarm from the machine.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="alarmID">The id of the alarm to remove.</param>
        /// <returns></returns>
        public StatusCode RemoveAlarm(
            RequestContext context,
            UnitModel model,
            int alarmID
            )
        {
            if (alarmID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.Alarms == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            List<AlarmType> alarmTypes = model.Dictionnaries.Alarms.ToList();

            foreach (AlarmType alarm in alarmTypes)
            {
                if (alarm.Id == alarmID)
                {
                    alarmTypes.Remove(alarm);
                    model.Dictionnaries.Alarms = alarmTypes.ToArray();
                    return StatusCodes.Good;
                }
            }
            return StatusCodes.BadIndexRangeNoData;
        }

        /// <summary>
        /// Remove a button from the machine.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="buttonID">The id of the button to remove</param>
        /// <returns></returns>
        public StatusCode RemoveButton(
            RequestContext context,
            UnitModel model,
            int buttonID
            )
        {
            if (buttonID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.Buttons == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            List<ButtonType> buttonTypes = model.Dictionnaries.Buttons.ToList();

            foreach (ButtonType button in buttonTypes)
            {
                if (button.Id == buttonID)
                {
                    buttonTypes.Remove(button);
                    model.Dictionnaries.Buttons = buttonTypes.ToArray();
                    return StatusCodes.Good;
                }
            }
            return StatusCodes.BadIndexRangeNoData;
        }

        /// <summary>
        /// Remove a stack light from the machine.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="stacklightID">The id of the stack light to remove</param>
        /// <returns></returns>
        public StatusCode RemoveStackLight(
            RequestContext context,
            UnitModel model,
            int stacklightID
            )
        {
            if (stacklightID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.StackLights == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            List<StackLightType> stacklightTypes = model.Dictionnaries.StackLights.ToList();

            foreach (StackLightType stacklight in stacklightTypes)
            {
                if (stacklight.Id == stacklightID)
                {
                    stacklightTypes.Remove(stacklight);
                    model.Dictionnaries.StackLights = stacklightTypes.ToArray();
                    return StatusCodes.Good;
                }
            }
            return StatusCodes.BadIndexRangeNoData;
        }

        /// <summary>
        /// Applies a command to a State Machine. If a command is not applicable to a State Machine in it's current state, do nothing.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="command">The command to apply</param>
        /// <returns></returns>
        public StatusCode SafeMoveNext(
            RequestContext context,
            UnitModel model,
            int command
            )
        {
            StateTransition transition = new StateTransition((State)model.CurrentState, (Command)command);
            Unit temp = new Unit((State)model.CurrentState);
            if (temp.GetTransitions().TryGetValue(transition, out State nextState))
            {
                UpdateState(model, (int)temp.MoveNext((Command)command));

                return StatusCodes.Good;
            }
            return StatusCodes.BadInvalidState;
        }

        /// <summary>
        /// Save the data of the machine to a .csv file.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="csvFileName">The name of the csv file to save as. (for example "data.csv")</param>
        /// <param name="delimiter">The delimiter of the .csv file. Usually a comma</param>
        /// <returns></returns>
        public StatusCode SaveDataToCSV(
            RequestContext context,
            UnitModel model,
            string csvFileName,
            string delimiter
            )
        {
            AlarmType[] tempAlarm = new AlarmType[] { };
            if (model.Dictionnaries.Alarms == null)
            {
                model.Dictionnaries.Alarms = tempAlarm;
            }

            StackLightType[] tempStackLight = new StackLightType[] { };
            if (model.Dictionnaries.StackLights == null)
            {
                model.Dictionnaries.StackLights = tempStackLight;
            }

            ButtonType[] tempButton = new ButtonType[] { };
            if (model.Dictionnaries.Buttons == null)
            {
                model.Dictionnaries.Buttons = tempButton;
            }

            string path = @"Data/" + csvFileName;

            using (StreamWriter writer = new StreamWriter(path))
            {

                writer.WriteLine("Machine name" + delimiter + MachineName);
                writer.WriteLine("State" + delimiter + (State)CurrentState);
                writer.WriteLine("");

                writer.Write("AlarmsID" + delimiter);
                foreach (AlarmType alarm in model.Dictionnaries.Alarms)
                {
                    writer.Write(alarm.Id);
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.Write("Command" + delimiter);
                foreach (AlarmType alarm in model.Dictionnaries.Alarms)
                {
                    writer.Write((Command)alarm.AlarmTransition);
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.Write("Message" + delimiter);
                foreach (AlarmType alarm in model.Dictionnaries.Alarms)
                {
                    writer.Write(alarm.AlarmMessage.ToString());
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.Write("AlarmState" + delimiter);
                foreach (AlarmType alarm in model.Dictionnaries.Alarms)
                {
                    if (alarm.On == true)
                    {
                        writer.Write("TRUE");
                    }
                    else
                    {
                        writer.Write("FALSE");
                    }
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.WriteLine("");
                writer.Write("StackLightID" + delimiter);
                foreach (StackLightType stacklight in model.Dictionnaries.StackLights)
                {
                    writer.Write(stacklight.Id);
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.Write("Description" + delimiter);
                foreach (StackLightType stacklight in model.Dictionnaries.StackLights)
                {
                    writer.Write(stacklight.Description.ToString());
                    writer.Write(delimiter);
                }

                writer.WriteLine("");
                writer.Write("StackLightState" + delimiter);
                foreach (StackLightType stacklight in model.Dictionnaries.StackLights)
                {
                    if (stacklight.On == true)
                    {
                        writer.Write("TRUE");
                    }
                    else
                    {
                        writer.Write("FALSE");
                    }
                    writer.Write(delimiter);
                }

                writer.WriteLine("");

                writer.WriteLine("");
                writer.Write("CommandID" + delimiter);
                foreach (ButtonType button in model.Dictionnaries.Buttons)
                {
                    for (int i = 0; i < button.Commands.Count; i++)
                    {
                        writer.Write(button.Id);
                        writer.Write(delimiter);
                    }
                }


                writer.WriteLine("");
                writer.Write("CommandName" + delimiter);
                foreach (ButtonType button in model.Dictionnaries.Buttons)
                {
                    for (int i = 0; i < button.Commands.Count; i++)
                    {
                        writer.Write(button.ButtonName);
                        writer.Write(delimiter);
                    }
                }


                writer.WriteLine("");
                writer.Write("Actions" + delimiter);
                foreach (ButtonType button in model.Dictionnaries.Buttons)
                {
                    foreach (Command c in button.Commands)
                    {
                        writer.Write(c);
                        writer.Write(delimiter);
                    }
                }
            }
            return StatusCodes.Good;
        }

        /// <summary>
        /// Save the data of the machine to a database file. (This may be broken)
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="DBFileName"></param>
        /// <returns></returns>
        public StatusCode SaveDataToDB(
            RequestContext context,
            UnitModel model,
            string DBFileName
            )
        {
            Unit unit = new Unit((State)model.CurrentState);

            if (model.Dictionnaries.Alarms == null)
            {
                model.Dictionnaries.Alarms = new AlarmType[] { };
            }
            if (model.Dictionnaries.StackLights == null)
            {
                model.Dictionnaries.StackLights = new StackLightType[] { };
            }
            if (model.Dictionnaries.Buttons == null)
            {
                model.Dictionnaries.Buttons = new ButtonType[] { };
            }

            foreach (AlarmType alarmType in model.Dictionnaries.Alarms)
            {
                unit.AddAlarm(alarmType.Id, (Command)alarmType.AlarmTransition, alarmType.AlarmMessage);
                if (alarmType.On)
                {
                    unit.TriggerAlarm(alarmType.Id);
                }
            }

            foreach (StackLightType stacklightType in model.Dictionnaries.StackLights)
            {
                unit.AddStackLight(stacklightType.Id, stacklightType.Description);
                if (stacklightType.On)
                {
                    unit.TriggerStackLight(stacklightType.Id);
                }
            }

            foreach (ButtonType buttonType in model.Dictionnaries.Buttons)
            {
                List<Command> commandsList = new List<Command>();
                foreach (Command command in buttonType.Commands)
                {
                    commandsList.Add(command);
                }
                unit.AddCommandMachine(buttonType.Id, buttonType.ButtonName, commandsList);
            }

            unit.SetMachineName(model.MachineName);
            unit.SetState((State)model.CurrentState);
            unit.SaveDataToDB();
            return StatusCodes.Good;
        }

        /// <summary>
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public StatusCode SetMachineName(
            RequestContext context,
            UnitModel model,
            string name
            )
        {
            model.MachineName = name;
            return StatusCodes.Good;
        }

        /// <summary>
        /// Triggers an alarm. This will change the state of the alarm to ON and try to change the state of the machine.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="alarmID">The ID of the alarm to trigger</param>
        /// <returns></returns>
        public StatusCode TriggerAlarm(
            RequestContext context,
            UnitModel model,
            int alarmID
            )
        {
            if (alarmID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.Alarms == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }


            bool changed = false;
            List<AlarmType> alarmTypes = new List<AlarmType>();

            foreach (AlarmType alarm in model.Dictionnaries.Alarms)
            {
                if (alarm.Id == alarmID)
                {
                    AlarmType newAlarm = new AlarmType();
                    newAlarm.Id = alarm.Id;
                    newAlarm.AlarmMessage = alarm.AlarmMessage;
                    newAlarm.AlarmTransition = alarm.AlarmTransition;
                    newAlarm.On = true;
                    alarmTypes.Add(newAlarm);

                    SafeMoveNext(context, model, newAlarm.AlarmTransition);

                    changed = true;
                }
                else
                {
                    alarmTypes.Add(alarm);
                }
            }
            if (changed == false)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            model.Dictionnaries.Alarms = alarmTypes.ToArray();
            return StatusCodes.Good;
        }

        /// <summary>
        /// Triggers a button.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="buttonID"></param>
        /// <returns>ID of the button to trigger</returns>
        public StatusCode TriggerButton(
            RequestContext context,
            UnitModel model,
            int buttonID
            )
        {
            if (buttonID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.Buttons == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            bool changed = false;
            List<Command> commands = new List<Command>();

            foreach (ButtonType button in model.Dictionnaries.Buttons)
            {
                if (button.Id == buttonID)
                {
                    foreach (Command command in button.Commands)
                    {
                        commands.Add(command);
                    }
                    changed = true;
                    break;
                }
            }

            if (changed == false)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            Unit unit = new Unit((State)model.CurrentState);
            unit.AddCommandMachine(1, "temp", commands);
            unit.TriggerCommandMachine(1);

            UpdateState(model, (int)unit.CurrentState);

            return StatusCodes.Good;
        }

        /// <summary>
        /// Triggers a stack light. This will change the state of the stack light to ON.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="stacklightID">ID of the stack light to trigger</param>
        /// <returns></returns>
        public StatusCode TriggerStackLight(
            RequestContext context,
            UnitModel model,
            int stacklightID
            )
        {
            if (stacklightID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.StackLights == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            bool changed = false;
            List<StackLightType> stacklightTypes = new List<StackLightType>();

            foreach (StackLightType stacklight in model.Dictionnaries.StackLights)
            {
                if (stacklight.Id == stacklightID)
                {
                    StackLightType newStackLight = new StackLightType();
                    newStackLight.Id = stacklight.Id;
                    newStackLight.Description = stacklight.Description;
                    newStackLight.On = true;
                    stacklightTypes.Add(newStackLight);
                    changed = true;
                }
                else
                {
                    stacklightTypes.Add(stacklight);
                }
            }
            if (changed == false)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            model.Dictionnaries.StackLights = stacklightTypes.ToArray();
            return StatusCodes.Good;
        }

        /// <summary>
        /// Sets the state of the alarm to OFF
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="alarmID">ID of the alarm to turn off</param>
        /// <returns></returns>
        public StatusCode UntriggerAlarm(
            RequestContext context,
            UnitModel model,
            int alarmID
            )
        {
            if (alarmID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.Alarms == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            bool changed = false;
            List<AlarmType> alarmTypes = new List<AlarmType>();

            foreach (AlarmType alarm in model.Dictionnaries.Alarms)
            {
                if (alarm.Id == alarmID)
                {
                    AlarmType newAlarm = new AlarmType();
                    newAlarm.Id = alarm.Id;
                    newAlarm.AlarmMessage = alarm.AlarmMessage;
                    newAlarm.AlarmTransition = alarm.AlarmTransition;
                    newAlarm.On = false;
                    alarmTypes.Add(newAlarm);
                    changed = true;
                }
                else
                {
                    alarmTypes.Add(alarm);
                }

            }
            if (changed == false)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            model.Dictionnaries.Alarms = alarmTypes.ToArray();
            return StatusCodes.Good;
        }

        /// <summary>
        /// Sets the state of the stack light to OFF
        /// </summary>
        /// <param name="context"></param>
        /// <param name="model"></param>
        /// <param name="stacklightID">ID of the stack light to turn off</param>
        /// <returns></returns>
        public StatusCode UntriggerStackLight(
            RequestContext context,
            UnitModel model,
            int stacklightID
            )
        {
            if (stacklightID < 0)
            {
                return StatusCodes.BadIndexRangeNoData;
            }
            if (model.Dictionnaries.StackLights == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }


            bool changed = false;
            List<StackLightType> stacklightTypes = new List<StackLightType>();

            foreach (StackLightType stacklight in model.Dictionnaries.StackLights)
            {
                if (stacklight.Id == stacklightID)
                {
                    StackLightType newStackLight = new StackLightType();
                    newStackLight.Id = stacklight.Id;
                    newStackLight.Description = stacklight.Description;
                    newStackLight.On = false;
                    stacklightTypes.Add(newStackLight);
                    changed = true;
                }
                else
                {
                    stacklightTypes.Add(stacklight);
                }

            }
            if (changed == false)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            model.Dictionnaries.StackLights = stacklightTypes.ToArray();
            return StatusCodes.Good;
        }

    }
}

